<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title></title>
</head>
<body>
<script type="text/javascript">
    //    function fn() {
    //        var i = 10;
    //        return function (n) {
    //            console.log(n + (++i));
    //        }
    //    }
    //    var f = fn();
    //    f(15);//->26  //问题就出在作用域能否销毁的问题上，这个作用域不能销毁。被f占用呢，
    //    f(20);//->32
    //    f(30);//->43
    //    fn()(15);//->26   //
    //    fn()(20);//->31  //先让fn执行，返回一个小的函数地址，紧接着小的函数执行，传递20
    //    fn()(30);//->41

    //思考题：


       // function fn(i) {
       //     return function (n) {
       //         console.log(n + (i++));
       //     }
       // }
       // var f = fn(10);
       // f(20);//30
       // fn(20)(40);//60  执行一个关闭一个
       // fn(30)(50);//80
       // f(30);//41

    //2、这是在全局作用域下，i的值会累加，不会从新赋值
      //  var i = 10;
      //  function fn() {
      //      return function (n) {
      //          console.log(n + (++i));
      //      }
      //  }
      //  var f = fn();
      //  f(20);//31
      //  fn()(20);//32
      //  fn()(30);//43
      //  f(30);//44

//    //1、
  //  function fn(i) {
  //      return function (n) {
  //          console.log(n + (i++));
  //      }
  //  }
  //  var f = fn(10);
  //  f(20); //30
  //  fn(20)(40); //60
  //  fn(30)(50); //80
  //  f(30); //41
//
//    //2、
   var i = 10;
   function fn() {
       return function (n) {
           console.log(n + (++i));
       }
   }
   var f = fn();
  //  f(20); //31
  //  fn()(20); //32
  //  fn()(30); //43
  //  f(30); //44

</script>
</body>
</html>
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title></title>
</head>
<body>
<script type="text/javascript">


    //    console.log(obj1);//->undefined
    //    var obj1 = {name: "张三"};
    //    var obj2 = obj1;
    //    obj2.name = "李四";
    //    console.log(obj1.name);//->"李四"

    //    console.log(sum);//->输出的不是undefined,而是当前函数本身(因为在预解释的时候声明和定义都完成了)
    //    sum(1, 2);//->3 发现及时看上去是在函数定义的代码之上执行的,但是也是可以执行的,因为在JS整体还没执行的时候我们的sum就已经定义完成了,所以不管在哪都可以执行
    //    function sum(num1, num2) {
    //        var total = null;
    //        total = num1 + num2;
    //        console.log(total);
    //    }//->17~21行在全局作用域下预解释的时候就完成了声明+定义,换句话说这些代码都完成了,所以代码执行到这的时候就不在从新的执行这几行代码了,直接的跳过执行下面的
    //    sum(100, 200);//->300
    //预解释只发生在当前作用域下。例如：上面的代码在全局作用域下JS执行之前，只是把sum声明+定义了，而sum函数体中我们看到的var total都还是一些"代码字符串"而已，此时是不进行预解释的(只有在函数执行的时候才会预解释)


    //1、什么是预解释?
    //预解释：在当前作用域下，JS代码执行之前，首先会把带var/function关键字的进行提前的声明或者定义
    //声明 declare: var obj1; ->就是告诉浏览器我有一个全局的变量obj1啦  ->只声明一个变量还没有赋值的时候我们的默认值是undefined
    //定义 defined: obj1 = xxxfff000; ->就是给声明后的变量赋值

    //2、预解释是如何的操作的?
    //带var关键字的在预解释阶段只完成了提前的声明
    //带function关键字的在预解释阶段完成了声明和定义两个操作

    //关于浏览器中的一些知识点
    //1、当浏览器加载我们页面内的时候首先会提供一个供JS代码执行的环境->全局作用域(window)
    //在全局作用域中定义的变量我们称为全局变量

    //2、在JS中存在两种内存空间
    //栈内存(作用域->全局作用域或者是私有的作用域)：提供一个JS代码执行的环境，而且我们的预解释都是发生在栈内存中的
    //堆内存：用来存储引用数据类型值的，对于对象来说存储的是属性名和属性值，对于函数来说存储的是函数体中的代码字符串

    //3、当函数执行的时候首先会形成一个新的私有的作用域(栈内存)
    //作用：
    //1)让函数体中存储的代码字符串变为代码执行
    //2)保护函数私有作用域中的私有的变量是不受外界的影响的->"闭包"

    //具体的执行步骤：
    //1)首先给函数定义的形参进行赋值
    //2)进行私有作用域中的预解释
    //3)让之前存储的代码字符串变为JS代码从上到下执行

    //4、什么是私有的变量?
    //在JS中我们的私有变量有且只有两种情况
    //1)在私有作用域中声明过的变量(在函数体中带var的)
    //2)形参变量也是函数的私有的变量
    //->在函数体中看一个变量是否为私有的,首先看它是否为形参，然后在看是否带var，如果两者有其一就是私有的，否则就不是私有的



    //1、当浏览器加载HTML页面的时候,首先会提供一个供JS代码执行的环境->"全局作用域"(window)
    //在全局作用域中声明的变量叫做全局变量->不仅仅是全局变量,在"全局作用域下"声明的变量也相当于给window增加了属性名,例如:
    //    //window下的预解释:
    //    //var num; ->num是全局变量,也是window的一个属性名->window.num=undefined;
    //    console.log(num);//->undefined
    //    var num = 10;//->num = 10;
    //    console.log(num);//->10
    //    console.log(window.num);//->10

    //2、预解释
    //在当前作用域下,JS代码从上到下执行之前,浏览器默认的会把带var/function关键字的进行提前的"声明"或者"定义"
    //声明 declare:告诉浏览器有这个名字  var num1; ->只是声明了但是没有赋值,默认的值是undefined
    //定义 defined:就是给声明的变量赋值  num1=12;

    //注意:
    //带var关键字的和带function关键字的在预解释的时候操作是不一样的
    //"var" : 在预解释的时候只是提前的声明
    //"function" : 在预解释的时候完成了声明+定义


    var num1 = 12;
    var num2 = num1;
    num2 = 13;
    console.log(num1);

    var obj1 = {name: "刘洁"};
    var obj2 = obj1;
    obj2.name = "222";
    console.log(obj1.name);

    function fn() {//->在预解释的时候已经完成了fn的声明+定义,所以当代码执行到39~43行的时候直接的跳过即可
        var total = null;
        total = 100 + 100;
        console.log(total);
    }
    fn();

    //一个函数的定义赋值操作:
    //1)首先开辟一个新的内容空间,浏览器为其分配一个16进制的地址
    //2)把函数体中的代码当做字符串存储到这个空间中
    //3)把空间的地址赋值给我们的函数名,此时函数名代表的就是整个函数本身,例如：fn代表的是当前整个函数(函数定义的部分)、fn()代表的是让当前函数执行

    //一个函数执行的操作:
    //1)当函数执行的时候,首先会形成一个新的私有的作用域,作用有两个:
    //->让函数体中存储的字符串变为JS代码执行
    //->保护函数体中的私有的变量不受外界的影响(外面不能获取也不能修改),我们把函数的这个保护的机制叫做"闭包"
    //2)给形参赋值
    //3)私有作用域下的预解释
    //4)私有作用域中的代码从上到下执行

    //函数中的私有变量有且只有两种
    //1)函数的形参都是私有的变量
    //2)在函数中预解释的时候声明过的变量

    //3、JS中的内存
    //栈内存(作用域):全局作用域、函数执行形成的私有的作用域 ->提供JS代码执行的环境
    //堆内存:存储引用数据类型值的,对象存储的是属性名和属性值,函数存储的是代码字符串
</script>
<script type="text/javascript">
    //预解释的注意点

    //1、不管条件是否成立,判断体中的内容都要进行预解释
    //    //预解释:var a; ->在全局作用域中声明一个变量相当于给window这个对象增加了一个属性名window.a=undefined;
    //    if (!("a" in window)) {//->"a" in window 判断"a"是否为window的一个属性名,因为预解释的时候声明了a,所以"a" in window的结果是true,取反为false,条件不成立,a=12这个赋值的操作是执行不了的了
    //        var a = 12;
    //    }
    //    console.log(a);//->undefined

    //2、预解释的时候只对 “=”左边的变量进行预解释，右边代表的都是值，所以是不进行预解释的
    //    fn();//->可以在上面执行,因为预解释的时候fn声明+定义都完成了
    //    function fn() {
    //        console.log("ok");
    //    }

    //fn();//->Uncaught TypeError: fn is not a function 因为只能对左边的var fn进行预解释,只有声明,此时的fn的值还是undefined,不是一个函数不能执行
    //匿名函数之函数表达式：把函数定义的部分当做一个值赋值给我们的变量/元素的事件
    //        fn()在这里就不能执行，预解释只解释左侧
    //        var fn = function () {
    //            console.log("ok");
    //        };
    //        fn();//->"ok"

    //3、在全局作用域下预解释的时候,我们的自执行函数中的function是不参与的;当代码执行到对应的区域时,声明+定义+执行一起都完成了;

    //匿名函数之自执行函数:定义和执行都一起完成的函数
    //    ;(function (num) {
    //        console.log(num);
    //    })(100);//->定义一个匿名函数并且执行,执行的时候给形参num赋值为100,在最前面加一个";"的目的是为了防止上面的代码结束不加";"

    //下面也是自执行函数,前面加的所有特殊符合都是保证语法正常的,没有特殊的意义,例如：写个!不是取反,写个+也不是相加
    //    ~function(num){}(100);
    //    !function(num){}(100);
    //    +function(num){}(100);
    //    -function(num){}(100);


    //4、虽然函数体中“return”下面的代码是不执行的,但是需要进行私有作用域下的预解释;而“return”后面紧跟着的是返回的值,是不参与预解释的;
    var a = 15;
    function fn() {
        //预解释：var a; ->a是私有的变量
        //代码执行：
        console.log(a);//->undefined
//            return function () {};//->函数体中return下面的代码都不在执行的 ->return xxxfff111; 返回的是function这个函数对应的地址
        var a = 13;  // 虽然不再执行，但会参与预解释
    }
    fn();


    //    另类问题
    //        var f = fn()
    //            f（）  //但这个函数执行的时候小函数是进行预解释的


    //5、在预解释的时候,如果发现了名字冲突了,,但是需要重新的赋值
    //   循环第一轮（预解释）只是声明加定义，不会执行， 第二轮才是代码执行
    //    fn();//->2
    //    function fn(){console.log(1);}声明+定义
    //    fn();//->2
    //    var fn=13;//->fn=13  把13的值给了fn var关键字是只声明不定义，在执行的时候才会赋值，执行第60行就变成13()了，就会报错
    //     fn();//->13() 抱错:fn is not a function 本行代码报错的话,下面的代码都不在执行了，  只是声明过，还少赋值，赋值后就变成了13（），也就报错了。
    //    function fn(){console.log(2);}声明+（这里把定义修改了，fn在哪里执行都可）
    //    fn(); //这行代码不会执行
    //不仅在全局作用域下声明的变量是给window增加属性名,而且在全局下定义的函数也是给window增加属性名,例如:
    //var fn=12;//->window.fn=12;
    //function fn(){}//->window.fn=xxxfff000;
    //总结:在JS中不管是变量还是函数,他们的名字如果一样的了,都算相互冲突,JS中一个名字就代表一个变量,只不过存储的值可以是任何的数据类型的(变量的松散性)

    //window下的预解释:
    //声明+定义 fn=xxxfff000 ->1
    //声明 var fn; (其实没啥意思)
    //声明+定义 fn=xxxfff111 ->2 (不需要重新的声明,但是需要重新的赋值)
    //->此时window下有一个fn,存储的值xxxfff111
    //代码执行执行
    //    fn();//->2
    //    function fn(){console.log(1);}
    //    fn();//->2
    //    var fn=13;//->fn=13
    //    fn();//->13() 报错
    //    function fn(){console.log(2);}
    //    fn();
</script>
</body>
</html>